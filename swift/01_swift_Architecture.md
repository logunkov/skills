# Swift architecture

## ООП
Принципы объектно-ориентированного программирования:  

* <p align="justify"><b>Абстракция</b> - это выделение и представление существенных отличительных свойств, характеристик объекта в терминах программирования. Основная идея состоит в том, чтобы представить объект с минимальным набором полей и методов, при этом с достаточной точностью для решаемой задачи.</p>
* <p align="justify"><b>Инкапсуляция</b> - это концепция, с помощью которой мы скрываем данные и методы от внешнего вмешательства и использования, механизм объединения данных в единый компонент, дающий возможность защитить и спрятать их. То есть ограничить доступ одних компонентов программы к другим.</p>
* <p align="justify"><b>Наследование</b> - это возможность порождать один класс от другого с сохранением всех свойств и методов класса-предка (суперкласса), добавляя при необходимости новые свойства и методы.</p>
* <p align="justify"><b>Полиморфизм</b> - это свойство, при котором разные типы поддерживают один и тот же интерфейс. Что предоставляет возможность использовать классы-потомки в контексте, который был предназначен для супер-класса (класса-предка). То есть использовать различные реализации классов с одинаковым интерфейсом так, будто это один класс.</p>

Виды полиморфизма:

* <p align="justify"><b>Статический</b> – Overloading.</p>
* <p align="justify"><b>Динамический</b> – Overriding.</p>
* <p align="justify"><b>Ad-hoc</b> – Overloading.</p>

* <p align="justify"><b>Overloading</b> – перегрузка метода.</p>
* <p align="justify"><b>Overriding</b> – переопределение метода.</p>

### Недостатки ООП
<p><font color="red">✓</font> Значительная глубина абстракции</p>
<p><font color="red">✓</font> Наследование "размывает код"</p>
<p><font color="red">✓</font> Инкапсуляция снижает скорость доступа к данным</p>
<p><font color="red">✓</font> Динамическое создание и уничтожение объектов</p>
<p><font color="red">✓</font> Ограничение Swift</p>

### Классы
<p align="justify"><b>Класс</b> – главное средство управления сложностью. Наследование полезно, но повышает сложность.</p>

Стоит избегать следующие классы:

* Божественные классы - все знает про другие классы и управляем ими.  
* Нерелевантный класс - класс имеет только данные.  
* Класс с именами глаголов - класс иммет только формы поведения.

## ПОП
Протоколо-ориентированное программирование - это парадигма программирования, которая пытается решить недостатки ООП и делает это на основе протоколов.

### Достоинства ПОП
<p align="justify"><font color="green">✓</font> Протокол может использоваться не только классом, но и структурами и перечислениями. Поддержка value-типов (и классов).</p>
<p align="justify"><font color="green">✓</font> Классы, структуры, перечисления могут соответствовать нескольким протоколам.</p>
<p align="justify"><font color="green">✓</font> Extension позволет добавить классу/структуре/enum-у соотвествие протоколу. При этом нам не нужен доступ к коду этих типов, они могут содержаться и в сторонней библиотеке (Retroactive modeling).</p>
<p align="justify"><font color="green">✓</font> Не навязыват данные объекта(поля базового класса).</p>
<p align="justify"><font color="green">✓</font> Не обременяет инициализацией (базового класса).</p>
<p align="justify"><font color="green">✓</font> Дает понять, что реализовать.</p>

## KISS
<b>Keep it Short and Simple</b>
<p>«Сделай это коротким и простым»</p>

## DRY
<b>Don’t repeat yourself</b>
<p>«Не повторяйтесь»</p>

## YAGNI
<b>You ain’t gonna need it</b>
<p>«Вам это не понадобится»</p>

## Принципы SOLID
* <b>Single Responsibility Principle</b> - «Принцип единственной ответственности»
<p align="justify">У класса не больше одной причины (ответственности) для его изменения. Протокол не должен содержать много методов и сам класс содержать много строк кода.</p>

* <b>Open Closed Principle</b> - «Принцип открытости/закрытости»
<p align="justify">Программные сущности (классы, модули, функции и т.п.) должны быть открыты для расширения, но закрыты для изменения.</p>
<p align="justify">Это означает, что должна быть возможность изменять внешнее поведение классов, не внося физические изменения в сам класс. Следуя этому принципу, классы разрабатывают так, чтобы для подстройки класса к конкретным условиям применения было достаточно расширить его и переопределить некоторые фунцкии. Поэтому система должна быть гибкой, с возможностью работы в переменных условиях без изменения исходного кода. Используют интерфейсы.
<p align="justify">Если мы опубликовали интерфейс или зафиксировали абстракцию, то мы уже ее не можем изменять!</p>

* <b>Liskov Substitution Principle</b> - «Принцип подстановки Барбары Лисков»
<p align="justify">Объекты в программе можно заменить их наследниками без изменения свойств программы.</p>
<p align="justify">Это означает, что класс, разработанный путем расширения на основании базового класса, должен переопределять его методы так, чтобы не нарушалась функциональность с точки зрения клиента. То есть, если разработчик расширяет ваш класс и использует его в приложении, он не должен изменять ожидаемое поведение переопределенных методов.</p>

* <b>Interface Segregation Principle</b> - «Принцип разделения интерфейса»
<p align="justify">Клиенты не должны реализовывать методы, которые им не нужны.</p>
<p align="justify">Принцип разделения интерфейсов говорит о том, что слишком «толстые» интерфейсы необходимо разделять на более мелкие и специфические, чтобы клиенты мелких интерфейсов знали только о методах, необходимых в работе.</p>

* <b>Dependency Inversion Principle</b> - «Принцип инверсии зависимостей»
<p align="justify">Ни один класс не должен создавать свои зависимости. Клиент (класс) не должен зависеть от реализации, а должен зависеть от протокола.</p>

## Закон Деметры
<p align="justify">Цепочки вызовов не должны раскрывать реализации объектов, которые вызываются.
Аналогия из жизни: Если Вы хоите, чтобы собака побежала, глупо командовать ее лпами, лучше отдать команду собаке, а она уже разберется со своими лапами сама.</p>

## Рекомандации по созданию представлений
* Используйте поставляемые со стандартным SDK классы view controllers
* Создавайте view controller максимально автономным
* Не храните во view controller данные
* Используйте view controller для реакции на внешние объекты

## MVC
<image src="resources/MVC.png">

<p align="justify"><b>Model</b> — это сущность, которая описывают объект.</p>

<p align="justify"><b>View</b> — это сущность, которая отвечает за пользовательский интерфейс. Всеклассы фреймворка UIKit.</p>

<p align="justify"><b>Controller</b> — посредник между Model и View. Отвечает за изменения модели данных, реагируя на манипуляции пользователя с интерфейсом. Так же передает данные для отображения в интерфейс, используя изменения из Model.</p>

## MVP
<image src="resources/MVP.png">

<p align="justify"><b>Model</b> — это сущность, которая описывают объект.</p>

<p align="justify"><b>View</b> — это сущность, которая отвечает за пользовательский интерфейс. Всеклассы фреймворка UIKit.</p>

<p align="justify"><b>Presenter</b> — посредник между Model и View. Отвечает за изменения модели данных, реагируя на манипуляции пользователя с интерфейсом. Так же передает данные для отображения в интерфейс, используя изменения из Model.</p>

## MVVM
<image src="resources/MVVM.png">

<p align="justify"><b>Model</b> — это сущность, которая описывают объект.</p>

<p align="justify"><b>View</b> — представляет из себя пользовательский интерфейс, сюда же относится и вью контроллер. В данной схеме вью берет на себя часть обязанностей, выполняемых классом UIViewController.</p>

<p align="justify"><b>View Model</b>  — с одной стороны View Model представляет из себя статическую модель для отображения вью, т.е. модель интерфейса; а с другой — отвечает за сбор, интерпретацию и преобразование данных. Это позволяет разгрузить View Controller на столько, чтобы оставить в нем только те задачи, которые необходимы для отображения интерфейса и для реагирования на действия пользователя. При таком подходе вью контроллер выступает посредником между пользователем и моделью данных.</p>

## VIPER
<image src="resources/VIPER.png">

<p align="justify"><b>View</b> — вся задача вью заключается в том, что бы отображать полученные данные в интерфейсе и перенаправлять действия пользователя в Presenter. К этому слою относится и вью контроллер.</p>

<p align="justify"><b>Interactor</b> — можно сравнить с контроллером, который ни чего не знает о том, как будут отображаться данные. Интерактор обрабатывает поступающие события и решает, какой сервис должен быть вызван в той или иной ситуации. Здесь реализована бизнес —логика, для работы текущего модуля. Сервисы — это вспомогательные классы, которые рассматриваются как внешние зависимости, которые не являются частями модуля VIPER. Сервисы могут взаимодействовать друг с другом и с Entity.</p>

<p align="justify"><b>Entity</b> — это объекты модели, не содержащие никакой бизнес —логики. Entity не является компонентом модуля VIPER.</p>
<p align="justify"><b>Presenter</b> — содержит бизнес —логику, связанную с пользовательским интерфейсом, но при этом не зависит от UIKit. Все действия действия пользователя передаются в Presenter, который в свою очередь решает куда перенаправлять эти действия: в Router или в Interactor. Presenter может получать данные от Interactor’a, подготавливать их и отправлять во View для отображения.</p>

<p align="justify"><b>Router</b> — осуществляет навигацию между модулями (экранами). В классической схеме VIPER, в качестве раутера выступает слой, который называется Wireframe. Он отвечает не только за сам переход, но и за сборку модуля, на который осуществляется этот переход, поэтому очень часто можно встретить деление этого слоя на дополнительный слой. Это может быть Assembly или Configurator, который отвечает за сборку модуля и установку зависимостей между всеми его компонентами, тогда как Router несет ответственность непосредственно за сам переход.</p>
 
## Clesn Swift
<image src="resources/CleanSwift.png">

<p align="justify"><b>View</b> — storyboard’ы, XIB’ы или UI элементы, написанные через код.</p>

<p align="justify"><b>ViewController</b> — отвечает только за конфигурацию и взаимодействие с View. В контроллере не должно находиться никакой бизнес логики, взаимодействия с сетью, вычислений и так далее. Вью контроллер отвечает за отображение подготовленных презентатором данных и взаимодействует с пользователем. Вью контроллер не отвечает за расположение вью и всех его сабвью.</p>

<p align="justify"><b>Interactor</b> — в интеракторе содержится бизнес логика конкретного юзкейса (сцены). Вью контроллер передает в него действия пользователя, а задача последнего обработать эти действия. При необходимости интерактор может запросить у провайдера какие то данные. В качестве провайдера тут может выступать класс созданный для сетевых запросов или для работы с базой данных. При необходимости интерактор может иметь связь с воркерами, в которых реализована общая для разных интереакторов логика. Результат своей работы интерактор отправляет в презентатор в виде объекта Response Model.</p>

<p align="justify"><b>Worker</b> — зачастую бывает так, что в интеракторах различных модулей часть бизнес функций может пересекаться. В этом случае, что бы не дублировать один и тот же код в разных интеракторах создаются вспомогательные файлы Worker’ы, которые работают совместно с интеракторами и реализуют общую для разных модулей бизнес логику. В Worker можно выносить логику работы с сетью или базой данных.</p>

<p align="justify"><b>Presenter</b> — презентатор получает данные от интерактора. Презентатор тоже может иметь воркеры. Презентатор форматирует данные в базовые типы для отображения их на экране и передает их во вью контроллер через объект модели View —Model Вся схема в целом представляет из себя отдельный юзкейс или сцену, которая обычно связана с конкретным экраном. Для перехода на другой экран вью контроллер текущей сцены обращается к роутеру. В Clean Swift компоненты действуют как плагины. Это означает, что их можно менять местами при условии, что они соответствуют входным и выходным протоколам. При этом приложение по прежнему должно работать правильно.</p>