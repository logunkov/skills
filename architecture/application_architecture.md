# Application architecture

## Рекомандации по созданию представлений
* Используйте поставляемые со стандартным SDK классы view controllers
* Создавайте view controller максимально автономным
* Не храните во view controller данные
* Используйте view controller для реакции на внешние объекты

## MVC
<image src="resources/MVC.png">

<p align="justify"><b>Model</b> — это сущность, которая описывают объект.</p>

<p align="justify"><b>View</b> — это сущность, которая отвечает за пользовательский интерфейс. Всеклассы фреймворка UIKit.</p>

<p align="justify"><b>Controller</b> — посредник между Model и View. Отвечает за изменения модели данных, реагируя на манипуляции пользователя с интерфейсом. Так же передает данные для отображения в интерфейс, используя изменения из Model.</p>

## MVP
<image src="resources/MVP.png">

<p align="justify"><b>Model</b> — это сущность, которая описывают объект.</p>

<p align="justify"><b>View</b> — это сущность, которая отвечает за пользовательский интерфейс. Всеклассы фреймворка UIKit.</p>

<p align="justify"><b>Presenter</b> — посредник между Model и View. Отвечает за изменения модели данных, реагируя на манипуляции пользователя с интерфейсом. Так же передает данные для отображения в интерфейс, используя изменения из Model.</p>

## MVVM
<image src="resources/MVVM.png">

<p align="justify"><b>Model</b> — это сущность, которая описывают объект.</p>

<p align="justify"><b>View</b> — представляет из себя пользовательский интерфейс, сюда же относится и вью контроллер. В данной схеме вью берет на себя часть обязанностей, выполняемых классом UIViewController.</p>

<p align="justify"><b>View Model</b>  — с одной стороны View Model представляет из себя статическую модель для отображения вью, т.е. модель интерфейса; а с другой — отвечает за сбор, интерпретацию и преобразование данных. Это позволяет разгрузить View Controller на столько, чтобы оставить в нем только те задачи, которые необходимы для отображения интерфейса и для реагирования на действия пользователя. При таком подходе вью контроллер выступает посредником между пользователем и моделью данных.</p>

## VIPER
<image src="resources/VIPER.png">

<p align="justify"><b>View</b> — вся задача вью заключается в том, что бы отображать полученные данные в интерфейсе и перенаправлять действия пользователя в Presenter. К этому слою относится и вью контроллер.</p>

<p align="justify"><b>Interactor</b> — можно сравнить с контроллером, который ни чего не знает о том, как будут отображаться данные. Интерактор обрабатывает поступающие события и решает, какой сервис должен быть вызван в той или иной ситуации. Здесь реализована бизнес —логика, для работы текущего модуля. Сервисы — это вспомогательные классы, которые рассматриваются как внешние зависимости, которые не являются частями модуля VIPER. Сервисы могут взаимодействовать друг с другом и с Entity.</p>

<p align="justify"><b>Entity</b> — это объекты модели, не содержащие никакой бизнес —логики. Entity не является компонентом модуля VIPER.</p>
<p align="justify"><b>Presenter</b> — содержит бизнес —логику, связанную с пользовательским интерфейсом, но при этом не зависит от UIKit. Все действия действия пользователя передаются в Presenter, который в свою очередь решает куда перенаправлять эти действия: в Router или в Interactor. Presenter может получать данные от Interactor’a, подготавливать их и отправлять во View для отображения.</p>

<p align="justify"><b>Router</b> — осуществляет навигацию между модулями (экранами). В классической схеме VIPER, в качестве раутера выступает слой, который называется Wireframe. Он отвечает не только за сам переход, но и за сборку модуля, на который осуществляется этот переход, поэтому очень часто можно встретить деление этого слоя на дополнительный слой. Это может быть Assembly или Configurator, который отвечает за сборку модуля и установку зависимостей между всеми его компонентами, тогда как Router несет ответственность непосредственно за сам переход.</p>
 
## Clesn Swift
<image src="resources/CleanSwift.png">

<p align="justify"><b>View</b> — storyboard’ы, XIB’ы или UI элементы, написанные через код.</p>

<p align="justify"><b>ViewController</b> — отвечает только за конфигурацию и взаимодействие с View. В контроллере не должно находиться никакой бизнес логики, взаимодействия с сетью, вычислений и так далее. Вью контроллер отвечает за отображение подготовленных презентатором данных и взаимодействует с пользователем. Вью контроллер не отвечает за расположение вью и всех его сабвью.</p>

<p align="justify"><b>Interactor</b> — в интеракторе содержится бизнес логика конкретного юзкейса (сцены). Вью контроллер передает в него действия пользователя, а задача последнего обработать эти действия. При необходимости интерактор может запросить у провайдера какие то данные. В качестве провайдера тут может выступать класс созданный для сетевых запросов или для работы с базой данных. При необходимости интерактор может иметь связь с воркерами, в которых реализована общая для разных интереакторов логика. Результат своей работы интерактор отправляет в презентатор в виде объекта Response Model.</p>

<p align="justify"><b>Worker</b> — зачастую бывает так, что в интеракторах различных модулей часть бизнес функций может пересекаться. В этом случае, что бы не дублировать один и тот же код в разных интеракторах создаются вспомогательные файлы Worker’ы, которые работают совместно с интеракторами и реализуют общую для разных модулей бизнес логику. В Worker можно выносить логику работы с сетью или базой данных.</p>

<p align="justify"><b>Presenter</b> — презентатор получает данные от интерактора. Презентатор тоже может иметь воркеры. Презентатор форматирует данные в базовые типы для отображения их на экране и передает их во вью контроллер через объект модели View —Model Вся схема в целом представляет из себя отдельный юзкейс или сцену, которая обычно связана с конкретным экраном. Для перехода на другой экран вью контроллер текущей сцены обращается к роутеру. В Clean Swift компоненты действуют как плагины. Это означает, что их можно менять местами при условии, что они соответствуют входным и выходным протоколам. При этом приложение по прежнему должно работать правильно.</p>