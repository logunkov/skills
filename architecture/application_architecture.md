# Application architecture

## Черты хорошей архитектуры
<p align="justify"><font>✔️ </font>Легко откликается на изменения требований.</p>
<p align="justify"><font>✔️ </font>Позволяет улучшить точность оценки любых изменений системы.</p>
<p align="justify"><font>✔️ </font>Гарантирует тестируемость.</p>
<p align="justify"><font>✔️ </font>Облегчает поддержание быстрого и постоянного темпа.</p>
<p align="justify"><font>✔️ </font>Не зависит от фреймворков.</p>
<p align="justify"><font>✔️ </font>Не зависит от БД, UI, железа и внешнего мира.</p>

> Проектирование архитектуры это искусство, а не ремесло - всегда неизбежны те или иные компромиссы.

## Слои архитектуры
![](resources/architecture_layers.png)

### Передача данных
![](resources/data_transmission.png)

### Порядок зависимостей
![](resources/order_of_dependencies.png)

> Документирование архитектуры программного обеспечения (ПО) упрощает процесс коммуникации между разработчиками, позволяет зафиксировать принятые проектные решения и предоставить информацию о них эксплуатационному персоналу системы, повторно использовать компоненты и шаблоны проекта в других

## Определение Архитектуры
<p align="justify"><font>✔️ </font>выбор структурных элементов и их интерфейсов, с помощью которых составлена система.</p>
<p align="justify"><font>✔️ </font>соединение выбранных элементов структуры и поведения в более крупные системы.</p>
<p align="justify"><font>✔️ </font>архитектурный стиль, который направляет всю организацию - все элементы, их интерфейсы, их сотрудничество и их соединение.</p>

> Архитектура системы слабо влияет на работу системы. Существует масса систем с ужасной архитектурой, которые прекрасно работают. Их проблемы кроются не в функционировании, проблемы возникают в процессе развертывания, сопровождения и продолжительного развития&

> Архитектура гибкая, она живет и развивается параллельно с жизнью ПО.

## Декомпозиция
1. Восходящее проектирование
	2. Сначала создаем кирпичики, потом собираем их них все более сложные системы
2. Нисходящее проектирование
	1. Постепенная реализация модулей
	2. Строгое задание интерфейсов
	3. Активное использование заглушек
	4. Модули
		1. Четкая декомпозиция
		2. Минимизация
		3. Один модуль - одна функциональность
		4. Отсутствие побочных эффектов
		5. Независимость от других модулей

## Качество модулей в системе
![](resources/cohesion_coupling.png)
<p align="justify"><font>✔️ </font>Cohesion. Связность - степень, в которой задачи, выполняемые одним модулем, связаны друг с другом. Фокусировка модуля.</p>
<p align="justify"><font>✔️ </font>Coupling. Сочетаемость - мера того, насколько взаимосвязаны разные модули в программе.</p>

### Хорошая архитектура должна обладать:
<p align="justify"><font>✔️ </font>High cohesion - Сильной связностью (направленные на решение однойчеткой задачи)</p>
<p align="justify"><font>✔️ </font>Low coupling - Слабой сочетаемостью (как можно менее зависимые от других модулей)</p>

### Cohesion. Связность
<p align="justify"><font>✔️ </font>REP: Reuse/Release Equivalence Principle -принцип эквивалентности повторного использования и выпусков.</p>
<p align="justify"><font>✔️ </font>CCP: Common Closure Principle - принцип согласованного изменения.</p>
<p align="justify"><font>✔️ </font>CRP: Common Reuse Principle - принцип совместного повторного использования.</p>

### Coupling. Сочетаемость
<p align="justify"><font>✔️ </font>ADP: Acyclic Dependencies Principle - принцип ацикличности зависимостей.</p>
<p align="justify"><font>✔️ </font>SDP: Stable Dependencies Principle - принцип устойчивых зависимостей.</p>
<p align="justify"><font>✔️ </font>SAP: Stable Abstractions Principle - принцип устойчивости абстракций.</p>

## Области вероятных изменений
<p align="justify"><font>✔️ </font>Бизнес-правила.</p>
<p align="justify"><font>✔️ </font>Зависимости от оборудования.</p>
<p align="justify"><font>✔️ </font>Ввод-вывод.</p>
<p align="justify"><font>✔️ </font>Нестандартные возможности языка, фреймворки, расширения.</p>
<p align="justify"><font>✔️ </font>Сложные аспекты проектирования и конструирования.</p>
<p align="justify"><font>✔️ </font>Переменные статуса.</p>
<p align="justify"><font>✔️ </font>Размеры структур данных.</p>

> Тестируемость архитектуры определяет, насколько легко нам будет писать юнит-тесты, а чаще всего - сможем ли мы их писать в принципе.

## MVx
<p align="justify"><b>Model</b> — ответственные за данные домена или слой доступа к данным, который манипулирует данным.</p>
<p align="justify"><b>View</b> — ответственные за уровень представления (UI); для iOS это все, что начинается с префикса UI.</p>
<p align="justify"><b>Controller / Presenter / ViewModel</b> — посредник между Model и View. Отвечает за изменения Model, реагируя на действия пользователя. MVC или MVP или даже MVVM.</p>

## MVC
![](resources/MVC.png)
![](resources/MVC_problems.png)

<p align="justify"><b>Model</b> — это сущность, которая описывают объект.</p>

<p align="justify"><b>View</b> — это сущность, которая отвечает за пользовательский интерфейс. Всеклассы фреймворка UIKit.</p>

<p align="justify"><b>Controller</b> — посредник между Model и View. Отвечает за изменения модели данных, реагируя на манипуляции пользователя с интерфейсом. Так же передает данные для отображения в интерфейс, используя изменения из Model.</p>

## MVP
![](resources/MVP.png)
![](resources/MVP2.png)

<p align="justify"><b>Model</b> — это сущность, которая описывают объект.</p>

<p align="justify"><b>View</b> — это сущность, которая отвечает за пользовательский интерфейс. Всеклассы фреймворка UIKit.</p>

<p align="justify"><b>Presenter</b> — посредник между Model и View. Отвечает за изменения модели данных, реагируя на манипуляции пользователя с интерфейсом. Так же передает данные для отображения в интерфейс, используя изменения из Model.</p>

## MVVM
![](resources/MVVM.png)
![](resources/MVVM2.png)

<p align="justify"><b>Model</b> — это сущность, которая описывают объект.</p>

<p align="justify"><b>View</b> — представляет из себя пользовательский интерфейс, сюда же относится и вью контроллер. В данной схеме вью берет на себя часть обязанностей, выполняемых классом UIViewController.</p>

<p align="justify"><b>View Model</b>  — с одной стороны View Model представляет из себя статическую модель для отображения вью, т.е. модель интерфейса; а с другой — отвечает за сбор, интерпретацию и преобразование данных. Это позволяет разгрузить View Controller на столько, чтобы оставить в нем только те задачи, которые необходимы для отображения интерфейса и для реагирования на действия пользователя. При таком подходе вью контроллер выступает посредником между пользователем и моделью данных.</p>

## VIPER
![](resources/VIPER.png)

<p align="justify"><b>View</b> — вся задача вью заключается в том, что бы отображать полученные данные в интерфейсе и перенаправлять действия пользователя в Presenter. К этому слою относится и вью контроллер.</p>

<p align="justify"><b>Interactor</b> — можно сравнить с контроллером, который ни чего не знает о том, как будут отображаться данные. Интерактор обрабатывает поступающие события и решает, какой сервис должен быть вызван в той или иной ситуации. Здесь реализована бизнес —логика, для работы текущего модуля. Сервисы — это вспомогательные классы, которые рассматриваются как внешние зависимости, которые не являются частями модуля VIPER. Сервисы могут взаимодействовать друг с другом и с Entity.</p>

<p align="justify"><b>Entity</b> — это объекты модели, не содержащие никакой бизнес —логики. Entity не является компонентом модуля VIPER.</p>
<p align="justify"><b>Presenter</b> — содержит бизнес —логику, связанную с пользовательским интерфейсом, но при этом не зависит от UIKit. Все действия действия пользователя передаются в Presenter, который в свою очередь решает куда перенаправлять эти действия: в Router или в Interactor. Presenter может получать данные от Interactor’a, подготавливать их и отправлять во View для отображения.</p>

<p align="justify"><b>Router</b> — осуществляет навигацию между модулями (экранами). В классической схеме VIPER, в качестве раутера выступает слой, который называется Wireframe. Он отвечает не только за сам переход, но и за сборку модуля, на который осуществляется этот переход, поэтому очень часто можно встретить деление этого слоя на дополнительный слой. Это может быть Assembly или Configurator, который отвечает за сборку модуля и установку зависимостей между всеми его компонентами, тогда как Router несет ответственность непосредственно за сам переход.</p>
 
## Clesn Swift
![](resources/CleanSwift.png)
![](resources/clean_swift.png)

<p align="justify"><b>View</b> — storyboard’ы, XIB’ы или UI элементы, написанные через код.</p>

<p align="justify"><b>ViewController</b> — отвечает только за конфигурацию и взаимодействие с View. В контроллере не должно находиться никакой бизнес логики, взаимодействия с сетью, вычислений и так далее. Вью контроллер отвечает за отображение подготовленных презентатором данных и взаимодействует с пользователем. Вью контроллер не отвечает за расположение вью и всех его сабвью.</p>

<p align="justify"><b>Interactor</b> — в интеракторе содержится бизнес логика конкретного юзкейса (сцены). Вью контроллер передает в него действия пользователя, а задача последнего обработать эти действия. При необходимости интерактор может запросить у провайдера какие то данные. В качестве провайдера тут может выступать класс созданный для сетевых запросов или для работы с базой данных. При необходимости интерактор может иметь связь с воркерами, в которых реализована общая для разных интереакторов логика. Результат своей работы интерактор отправляет в презентатор в виде объекта Response Model.</p>

<p align="justify"><b>Worker</b> — зачастую бывает так, что в интеракторах различных модулей часть бизнес функций может пересекаться. В этом случае, что бы не дублировать один и тот же код в разных интеракторах создаются вспомогательные файлы Worker’ы, которые работают совместно с интеракторами и реализуют общую для разных модулей бизнес логику. В Worker можно выносить логику работы с сетью или базой данных.</p>

<p align="justify"><b>Presenter</b> — презентатор получает данные от интерактора. Презентатор тоже может иметь воркеры. Презентатор форматирует данные в базовые типы для отображения их на экране и передает их во вью контроллер через объект модели View —Model Вся схема в целом представляет из себя отдельный юзкейс или сцену, которая обычно связана с конкретным экраном. Для перехода на другой экран вью контроллер текущей сцены обращается к роутеру. В Clean Swift компоненты действуют как плагины. Это означает, что их можно менять местами при условии, что они соответствуют входным и выходным протоколам. При этом приложение по прежнему должно работать правильно.</p>