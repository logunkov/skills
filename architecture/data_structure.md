# Data structure

<p align="justify"> Стандартная библиотека Swift поставляется с тремя основными структурами данных - <b>Array</b>, <b>Dictionary</b> и <b>Sет</b>, каждая из которых имеет свой набор оптимизаций, плюсов и минусов.</p>

## Array
<p align="justify"><font>✔️</font> Доступ - <b>0 (1)</b>: чтение по индексу.</p>
<p align="justify"><font>✔️</font> Поиск - <b>O(n)</b>: проходим по всему массиву и ищем подходящий элемент.</p>
<p align="justify"><font>✔️</font> Вставка - <b>O(n)</b>: если в начало, то надо сдвигать массив, если в конец, то надо переносить массив в новую память.</p>
<p align="justify"><font>✔️</font> Удаление - <b>O(n)</b>: при удалении надо сдвигать элементы.</p>

## Set
<p align="justify"><font>✔️</font> Поиск - <b>0 (1)</b>: поиск по хеш-числу.</p>
<p align="justify"><font>✔️</font> Вставка - <b>0 (1)</b>: поиск по хеш-числу.</p>
<p align="justify"><font>✔️</font> Удаление - <b>0 (1)</b>: поиск по хеш-числу.</p>

### Как работает Set:
<p align="justify">Элемент → Хеш-функция → Хеш-код → Адрес памяти элемента.</p>
<p align="justify">Нам доступны из коробки методы нахождения пересечения множеств, исключений, вычитания, а еще взаимосвязи и равенства множеств, чем очень удобно пользоваться на практике.</p>

## Dictionary
<p align="justify"><font>✔️</font> Поиск - <b>0 (1)</b> поиск по хеш-числу.</p>
<p align="justify"><font>✔️</font> Вставка - <b>0 (1)</b> поиск по хеш-числу.</p>
<p align="justify"><font>✔️</font> Удаление - <b>0 (1)</b> поиск по хеш-числу.</p>

### Как работает Dictionary:
<p align="justify">Ключ → Хеш-функция → Хеш-код → Индекс массива.</p>
<p align="justify">Нам доступны из коробки методы нахождения пересечения множеств, исключений, вычитания, а еще взаимосвязи и равенства множеств, чем очень удобно пользоваться на практике.</p>

## Реализация связанного списка
<p align="justify">Что, если хочется стабильного порядка перебора как в массиве и преимуществ множеств.</p>
<p align="justify">Такой структурой данных является <b>Связный список</b>.</p>
<p align="justify"><font>✔️</font> Операции, проверяющие список на пустоту и сообщающие его размерность.</p>
<p align="justify"><font>✔️</font> Три операции добавления объекта в список (в начало, конец или внутрь после любого (п-го) элемента списка).</p>
<p align="justify"><font>✔️</font> Операция поиска элемента в списке.</p>
<p align="justify"><font>✔️</font> Три операции удаления элемента из списка (первого, последнего и указанного, если он был найден).</p>

## Реализация стека на основе массива
<p align="justify">Стек — это набор данных, в который можно добавлять или удалять элементы только с конца.</p>
<p align="justify">Элементы в стеке не доступны случайным образом.</p>
<p align="justify"><b>LIFO</b> (последним пришел, первым ушел).</p>
<p align="justify"><font>✔️</font> <b>push</b>: добавляет элемент в конец стека.</p>
<p align="justify"><font>✔️</font> <b>peek</b>: возвращает последний элемент стека.</p>
<p align="justify"><font>✔️</font> <b>pop</b>: возвращает последний элемент и удаляет его из стека.</p>
<p align="justify"><font>✔️</font> <b>isEmpty</b>: возвращает логическое значение, определяющее, пуст ли стек.</p>
<p align="justify"><font>✔️</font> <b>count</b>: возвращает количество элементов в стеке.</p>

## Реализация очереди на основе массива
<p align="justify">Элементы в очереди недоступны случайным образом.</p>
<p align="justify">Нам разрешено добавлять элементы только в конец и удалять элементы только из начала очереди.</p>
<p align="justify"><b>FIFO</b> (первым пришел, первым ушел).</p>

# Sort
<p align="justify"><font>✔️</font> Bubble Sort - O(n^2)</p>
<p align="justify"><font>✔️</font> Insertion Sort - O(n^2)</p>
<p align="justify"><font>✔️</font> Selection Sort - O(n^2)</p>
<p align="justify"><font>✔️</font> Binary Sort - O(log n)</p>
<p align="justify"><font>✔️</font> Quick Sort - O(n log n).</p>

## Bubble Sort
<p align="justify">Это простой алгоритм сортировки, в котором циклом многократно проходим через список для сортировки, сравниваем каждую пару соседних элементов и меняем их местами, если они находятся в неправильном порядке.</p>
<p align="justify">Таким образом получается, будто самые большие элементы поднимаются постепенно с самого дна массива, что напоминает поведение пузырьков, отсюда и название метода.</p>
<p align="justify">Проход по списку повторяется до тех пор, пока перестановки не понадобятся. Хотя алгоритм прост, он слишком медленный и непрактичный для большинства задач.</p>
<p align="justify">Он имеет сложность 0(n^2), но считается медленнее, чем сортировка вставками.</p>

## Quick Sort
<p align="justify">Это один из продвинутых алгоритмов. Он имеет сложность 0(n log n) и применяет стратегию "Разделяй и властвуй" (Divide and Conquer).</p>
<p align="justify">Эта комбинация приводит к улучшенной алгоритмической производительности. Быстрая сортировка сначала делит большой массив на два меньших подмассива: младшие элементы и старшие элементы. Затем Quicksort может рекурсивно сортировать подмассивы.</p>
Шаги:
<p align="justify">• Выберите из массива элемент, называемый pivot (опорной точкой).</p>
<p align="justify">• Переупорядочите массив так, чтобы все элементы со значениями меньше, чем pivot, располагались перед pivot, a все элементы со значениями, превышающими pivot, шли после него (равные значения могут идти в любом направлении). После этого разбиения pivot занимает свое конечное положение. Это называется операцией разделения.</p>
<p align="justify">• Рекурсивно примените вышеуказанные шаги к подмассиву элементов с меньшими значениями и отдельно к подмассиву элементов с большими значениями.</p>

## Сортировка в Swift
<p align="justify">Понимание алгоритмов сортировки и умение их писать важно, но может и не пригодиться в реальной разработке, так как в Swift из коробки доступна сортировка.</p>
<p align="justify">Для сортировки массива применяется метод sort.</p>
<p align="justify">Если метод sort сортирует оригинальный массив, то метод sorted() возвращает новый отсортированный массив, никак не изменяя старый.</p>
<p align="justify">Обе функции принимают параметр <b>by</b>, который задает принцип сортировки в виде функции, которая принимает два параметра. Оба параметра представляют тип элементов массива. На выходе функция возвращает объект Bool. Если это значение равно true, то первое значение ставится до второго, если false - то после.</p>
<p align="justify">Выражение <b>{$0 > $1}</b> представляет анонимную функцию, которая возвращает true, если значение первого параметра меньше второго, то есть в данном случае сортировка в обратном порядке. Мы можем задать более сложную логику, но в данном случае мы просто сравниваем два значения, поэтому мы можем упростить данный вызов: <b>numbers.sort(by: >)</b> и Swift опять же будет применять операцию > к обоим параметрам.</p>
<p align="justify">Но что делать, если в массивы лежат не базовые типы, а свои собственные структуры? Как сделать доступной сортировку в таком случае? Все просто можно прямо внутри функции сортировки указать условия по которому нужно сортировать ваши структуры <b>{ $0.name < $1.name }</b>.</p>
<p align="justify">Если структуру подписать под протокол <b>Comparable</b> и дать таким образом ей возможность быть сравниваемой, то можно использовать сокращенную запись функции сортировки <b>sort(by: >)</b>.</p>

# Под капотом
<p align="justify">Задумывались ли вы, что внутри Swift использует для реализации алгоритма поиска:</p>
<p align="justify"> - Если менее, чем 20 элементов, то применяется <b>сортировка вставками</b>. Именно этот тип лучше подходит для данных небольшого размера.</p>
<p align="justify"> - Если более 20 элементов, применяется <b>Интроспективная сортировка</b>, включающая в себя <b>быструю сортировку</b> до определённой глубины рекурсии <b>2*floor(log(N))</b>.</p>
<p align="justify"> - И переключается на <b>сортировку кучей</b>, она же пирамидальная сортировка.</p>
