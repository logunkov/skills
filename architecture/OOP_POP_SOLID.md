# Principles OOP, POP, SOLID
## OOP
Принципы объектно-ориентированного программирования:  

* <p align="justify"><b>Абстракция</b> - это выделение и представление существенных отличительных свойств, характеристик объекта в терминах программирования. Основная идея состоит в том, чтобы представить объект с минимальным набором полей и методов, при этом с достаточной точностью для решаемой задачи.</p>
* <p align="justify"><b>Инкапсуляция</b> - это концепция, с помощью которой мы скрываем данные и методы от внешнего вмешательства и использования, механизм объединения данных в единый компонент, дающий возможность защитить и спрятать их. То есть ограничить доступ одних компонентов программы к другим.</p>
* <p align="justify"><b>Наследование</b> - это возможность порождать один класс от другого с сохранением всех свойств и методов класса-предка (суперкласса), добавляя при необходимости новые свойства и методы.</p>
* <p align="justify"><b>Полиморфизм</b> - это свойство, при котором разные типы поддерживают один и тот же интерфейс. Что предоставляет возможность использовать классы-потомки в контексте, который был предназначен для супер-класса (класса-предка). То есть использовать различные реализации классов с одинаковым интерфейсом так, будто это один класс.</p>

Виды полиморфизма:

* <p align="justify"><b>Статический</b> – Overloading.</p>
* <p align="justify"><b>Динамический</b> – Overriding.</p>
* <p align="justify"><b>Ad-hoc</b> – Overloading.</p>

* <p align="justify"><b>Overloading</b> – перегрузка метода.</p>
* <p align="justify"><b>Overriding</b> – переопределение метода.</p>

### Недостатки ООП
<p><font color="red">✖️</font> Значительная глубина абстракции</p>
<p><font color="red">✖️</font> Наследование "размывает код"</p>
<p><font color="red">✖️</font> Инкапсуляция снижает скорость доступа к данным</p>
<p><font color="red">✖️</font> Динамическое создание и уничтожение объектов</p>
<p><font color="red">✖️</font> Ограничение Swift</p>

### Классы
<p align="justify"><b>Класс</b> – главное средство управления сложностью. Наследование полезно, но повышает сложность.</p>

Стоит избегать следующие классы:

* Божественные классы - все знает про другие классы и управляем ими.  
* Нерелевантный класс - класс имеет только данные.  
* Класс с именами глаголов - класс иммет только формы поведения.

## POP
Протоколо-ориентированное программирование - это парадигма программирования, которая пытается решить недостатки ООП и делает это на основе протоколов.

### Достоинства ПОП
<p align="justify"><font color="green">✔️</font> Протокол может использоваться не только классом, но и структурами и перечислениями. Поддержка value-типов (и классов).</p>
<p align="justify"><font color="green">✔️</font> Классы, структуры, перечисления могут соответствовать нескольким протоколам.</p>
<p align="justify"><font color="green">✔️</font> Extension позволет добавить классу/структуре/enum-у соотвествие протоколу. При этом нам не нужен доступ к коду этих типов, они могут содержаться и в сторонней библиотеке (Retroactive modeling).</p>
<p align="justify"><font color="green">✔️</font> Не навязыват данные объекта(поля базового класса).</p>
<p align="justify"><font color="green">✔️</font> Не обременяет инициализацией (базового класса).</p>
<p align="justify"><font color="green">✔️</font> Дает понять, что реализовать.</p>

## KISS
<b>Keep it Short and Simple</b>
<p>«Сделай это коротким и простым»</p>

## DRY
<b>Don’t repeat yourself</b>
<p>«Не повторяйтесь»</p>

## YAGNI
<b>You ain’t gonna need it</b>
<p>«Вам это не понадобится»</p>

## Принципы SOLID
* <b>Single Responsibility Principle</b> - «Принцип единственной ответственности»
<p align="justify">У класса не больше одной причины (ответственности) для его изменения. Протокол не должен содержать много методов и сам класс содержать много строк кода.</p>

* <b>Open Closed Principle</b> - «Принцип открытости/закрытости»
<p align="justify">Программные сущности (классы, модули, функции и т.п.) должны быть открыты для расширения, но закрыты для изменения.</p>
<p align="justify">Это означает, что должна быть возможность изменять внешнее поведение классов, не внося физические изменения в сам класс. Следуя этому принципу, классы разрабатывают так, чтобы для подстройки класса к конкретным условиям применения было достаточно расширить его и переопределить некоторые фунцкии. Поэтому система должна быть гибкой, с возможностью работы в переменных условиях без изменения исходного кода. Используют интерфейсы.
<p align="justify">Если мы опубликовали интерфейс или зафиксировали абстракцию, то мы уже ее не можем изменять!</p>

* <b>Liskov Substitution Principle</b> - «Принцип подстановки Барбары Лисков»
<p align="justify">Объекты в программе можно заменить их наследниками без изменения свойств программы.</p>
<p align="justify">Это означает, что класс, разработанный путем расширения на основании базового класса, должен переопределять его методы так, чтобы не нарушалась функциональность с точки зрения клиента. То есть, если разработчик расширяет ваш класс и использует его в приложении, он не должен изменять ожидаемое поведение переопределенных методов.</p>

* <b>Interface Segregation Principle</b> - «Принцип разделения интерфейса»
<p align="justify">Клиенты не должны реализовывать методы, которые им не нужны.</p>
<p align="justify">Принцип разделения интерфейсов говорит о том, что слишком «толстые» интерфейсы необходимо разделять на более мелкие и специфические, чтобы клиенты мелких интерфейсов знали только о методах, необходимых в работе.</p>

* <b>Dependency Inversion Principle</b> - «Принцип инверсии зависимостей»
<p align="justify">Ни один класс не должен создавать свои зависимости. Клиент (класс) не должен зависеть от реализации, а должен зависеть от протокола.</p>

## Закон Деметры
<p align="justify">Цепочки вызовов не должны раскрывать реализации объектов, которые вызываются.
Аналогия из жизни: Если Вы хоите, чтобы собака побежала, глупо командовать ее лпами, лучше отдать команду собаке, а она уже разберется со своими лапами сама.</p>